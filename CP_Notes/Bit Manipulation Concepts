
Read  Bit Manipulation from CP Agorithms (excellent this mostly derived from there only)

0) 100 ~ 00000100  (we can do this to fill all the bits of the type we are using  with leading zeroes )
1) Bits are indexed in 0 Based Indexing from right in left . So any text saying ith bit (it is in 0 based system)  Eg  bk.....b2b1b0  where each bit place has a value associated = 2^k.
2)  2^k : {
            - has the kth bit set from right (0 based indexing) , (kth bitn in 0 based indexing  has value 2^k) or,
            - has the (k+1)th bit set from right (1 based indeixing ), (kth bit  in 1 based indexing has value 2^(k+1-1)=2^k)
    }
    2^k-1 : {
            - has all the bits  are set from 0th bit to k-1 th bit (i.e. first k bits are set (fundamental counting is always 1 based),
              while in contrast first k bits of 2^k is off and k+1 th bit is set)
    }


3)  FUNDAMENTAL CONCEPTS REGARDING EACH OPERATOR:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         AND(&) : - bitwise AND compares each bit of its first operand with the corresponding bit of its second operand. 
                    If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

 a)  _ & 1 = 1st Bit (***) {fetches the first bit}  { x&1 gives only 1 or 0 based on the 0th bit of x} 

  eg  0 & 1 = 0
      1 & 1 = 1
b)  _ & 0 = 0 (**) {Clearing the bit}
     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          OR (|) : - bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand. 
                     If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

  a) _ | 0 = 1st Bit (***) {fetces the first bit}  { x|0 gives x always}

  eg  0 | 0 = 0
      1 | 0 = 1

  b) _ | 1 = 1 (**)   {Setting the bit}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          XOR (^) : - exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand. 
                      If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

     _ ^ 1 = ~1st Bit {Flips the first Bit}

  eg  0 ^ 1 = ~0=1
      1 & 1 = ~1=0
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      RIGHT SHIFT (>>) : - Shifts a number to the right by removing the last few binary digits of the number. 
                           Each shift by one represents an integer division by 2, so a right shift by k represents an integer division by ‚Ää2^k‚Ää.
       x>>k = ‚åäx/2^k‚åã
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      LEFT SHIFT (<<) : - Shifts a number to left by appending zero digits. In similar fashion to a right shift by ‚Ääk‚Ää, a left shift by k‚Ää represents
                          a multiplication by 2^k‚Ää.
       x>>k = x*2^k
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------4) AND Use-Case and Concepts:-
4) USEFUL TRICKS:_

    a}Set/flip/clear a bit:-
            - (1 << x)‚Ääis a number with only the ‚Ääx-th bit (0 based indexing) set, while ‚Ää~(1 << x )‚Ää is a number with all bits set except the x-th bit.
                        EXPLAINATION : {1 is a no. whose 0th bit is set so 1<<1 , jump =1 is a no. whose 1st bit is set (0 based)} 

            i) n | (1<<x) : sets the xth bit in the no. n . {Explaination : (1<<x) has only xth bit set and then using fundamental concept of OR}
           ii) n ^ (1<<x) : flips the xth bit in the no. n. {Explaination : (1<<x) has only xth bit set and then using fundamental concept of XOR }
          iii) n & ~(1<<x) : clear the x th bit in the no. n. {Explaination : ~(1<<x) has only xth bit of and then using fundamental concept of AND ; all the bits except x-th bit are unchanged when & with 1 and the x-th bit is cleared when & with 0}



5) CHECK IS A BIT IS SET OR NOT

            The value of the x-th bit can be checked by shifting the number x positions to the right, so that the 
            x-th bit is at the unit place, after which we can extract it by performing a bitwise & with 1. (fundamental property of AND)

    IMPLEMENTATION:-
    bool is_set(unsigned int number, int x) {
         return (number >> x) & 1;
    }

5a) Checking if the 0th or UNIT bit is set or not hence determinig odd/even repectively

     (x&1) = {
                  1, if x is odd
                  0 , if x is even
        }

        Proof:- 

        Using the fundamental concepts of AND

        Facts: If x is even its last bit is off eg 1 : 0001  eg 15 : 1111 (last bit set)
               If x is odd its last bit is on.  eg 2 : 0010  eg 16 :10000 (last bit off)

        so just referring the fundamental concept of AND 
        x&1  makes the last bit of the ans dependent on the last bit of x and all other bits of the ans is zero . So the ans is 1 if last bit of x is set (when x is odd)
              else the ans is 0 if last bit of x is off  (x is even)
        eg  x = 15 =  1111
                &1 =  0001
              -------------
                      0001 -> 1 -> x is odd
        eg x = 16 = 10000
               &1 = 00001
              -------------
                    00000->0-> x is even




6) CHECK IF A NUMBER IS DIVISIBLE BY A POWER OF 2 or NOT
       Using the and operation, we can check if a number ‚Ään‚Ää is even because n&1 = 1 if n is odd and n&1 = 0 if n is even.
       More generally, n is divisible by 2^k exacly when n&(2^k-1) = 0 


     We can calculate ‚Ää2^k by left shifting 1 by ‚Ääk‚Ää positions. The trick works, because ‚Ää2^k -1‚Ää is a number that consists of exactly k ones .
     And a number that is divisible by ‚Ää2^k‚Ää must have zero digits in those places. 

     {Explaination : so when n is &ed with 2^k-1(last k bits 1 and ahead from k+1 bits all are leading 0s) it fetches the k bits of n 
     (where 2^k is 1), clears all bits ahead of k bits of n in result (where 2^k is 0) so the resulting no. is zero when all fetch bits of n are 0 
     or last k bits of n are zero  which also means n is divisible by 2^ k}
     

     FACTS LEARNED FROM CN : When n is divided by 2^k , its last k bits gives the remainder or if its last k bits are zero n is evenly divisible by 2^k
            
            WHY THE LAST K BITS OF A NUMBER DIVISIBLE BY 2^k is 0: OR Last K bits is the Remainder When a number is divided by 2^k

            Vague Proof
            A number is divisible by 2^ùëò if it is a multiple of 2^k . This means that it can be written as ùëÅ = ùëö*(2^k) , where m is an integer.
            And when m=1 the number is  2^k where its k+1 th place (1 Based indexing) is 1 followed by k zeroes, next value of N is 2*2^k or 2^k+1 which has k+1
            0s at the end, next value of m=3 which also has no less k 0s at the end.

            If we add any other non zero binary digit in any of these k positions , the number will no longer be divisible bu 2^k , because we would 
            be adding values less that 2^k( tabhi toh last k bits zero nei hain) that would create a remainder.
            
     IMPLEMENTATION:
//here k is kth bit in 0 based indexing and counting wise last k bits are 0/1(this counting is always 1 based)

bool isDivisibleByPowerOf2(int n, int k) {
    int powerOf2 = 1 << k;
    return (n & (powerOf2 - 1)) == 0;
}


    
