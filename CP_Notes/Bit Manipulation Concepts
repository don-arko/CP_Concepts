
Read  Bit Manipulation from CP Agorithms (excellent)

0) 100 ~ 00000100  (we can do this to fill all the bits of the type we are using  with leading zeroes )
1) Bits are indexed in 0 Based Indexing from right in left . So any text saying ith bit (it is in 0 based system)  Eg  bk.....b2b1b0  where each bit place has a value associated = 2^k.
2)  2^k : {
            - has the kth bit set from right (0 based indexing) , (kth bitn in 0 based indexing  has value 2^k) or,
            - has the (k+1)th bit set from right (1 based indeixing ), (kth bit  in 1 based indexing has value 2^(k+1-1)=2^k)
    }
    2^k-1 : {
            - has all the bits  are set from 0th bit to k-1 th bit (i.e. first k bits are set (fundamental counting is always 1 based),
              while in contrast first k bits of 2^k is off and k+1 th bit is set)
    }


3)  FUNDAMENTAL CONCEPTS REGARDING EACH OPERATOR:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         AND(&) : - bitwise AND compares each bit of its first operand with the corresponding bit of its second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

  _ & 1 = 1st Bit (***) {fetches the first bit}

  eg  0 & 1 = 0
      1 & 1 = 1
     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          OR (|) : - bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand. If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

    _ | 0 = 1st Bit (***) {fetces the first bit}

  eg  0 | 0 = 0
      1 | 0 = 1

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
          XOR (^) : - exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand. If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.

     _ ^ 1 = ~1st Bit {Flips the first Bit}

  eg  0 ^ 1 = 1
      1 & 1 = 0
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4) AND Use-Case and Concepts:-

    a} (x&1) = {
                  1, if x is odd
                  0 , if x is even
        }

        Proof:- 

        Using the fundamental concept

        Facts: If x is even its last bit is off eg 1 : 0001  eg 15 : 1111 (last bit set)
               If x is odd its last bit is on.  eg 2 : 0010  eg 16 :10000 (last bit off)

        so just referring the fundamental concept of AND 
        x&1  makes the last bit of the ans dependent on the last bit of x and all other bits of the ans is zero . So the ans is 1 if last bit of x is set (when x is odd)
              else the ans is 0 if last bit of x is off  (x is even)
        eg  x = 15 =  1111
                &1 =  0001
              -------------
                      0001 -> 1 -> x is odd
        eg x = 16 = 10000
               &1 = 00001
              -------------
                    00000->0-> x is even
      b} More Generally (innfering from a) x is divisible by 2^k exacly when x & (2^k-1) = 0.

        Proof:-

    
